<script>
        // ==========================================
        //  1. 設定とロジック (変更なし)
        // ==========================================
        const TARGETS = { 
            bellA: [10.5, 10.1, 9.8, 9.4], 
            rb: [409.6, 397.2, 350.5, 312.1]
        };

        // 信頼度計算（3000G未満はベルを疑う）
        function calculateReliability(trials) {
            if (trials < 300) return 0.1;
            if (trials < 1000) return 0.4;
            if (trials < 3000) return 0.6;
            return 1.0;
        }

        // 解析メインロジック
        function analyze(data) {
            let s = { 1: 1.0, 2: 1.0, 5: 1.0, 6: 1.0 };
            const trials = data.totalGames || 0;
            if (trials === 0) return { 1: "0.0", 2: "0.0", 5: "0.0", 6: "0.0" };

            const rel = calculateReliability(trials);

            [1, 2, 5, 6].forEach((set, i) => {
                const bExp = trials / TARGETS.bellA[i];
                const rExp = trials / TARGETS.rb[i];
                
                // ベルA (信頼度補正)
                if (data.bellACount > 0) {
                    s[set] *= (1 - rel) + (Math.exp(-Math.pow(data.bellACount - bExp, 2) / (2 * bExp)) * rel);
                }
                // RB (信頼度補正)
                if (data.rbCount > 0) {
                    s[set] *= (1 - rel) + (Math.exp(-Math.pow(data.rbCount - rExp, 2) / (2 * rExp)) * rel);
                }
            });

            // --- 鉄の掟 ---
            // 1. RB中ハズレ (1・2 即死)
            if (data.rbHazure > 0) { s[1] = 0; s[2] = 0; }

            // 2. BB中ハズレ (高設定超優遇)
            if (data.bbHazure > 0) {
                s[1] *= (1/16384); s[2] *= (1/16384); 
                s[5] *= (1/2048); s[6] *= (1/1489); 
            }

            // 3. BB中チェリー+ベルはずれ (偶数優遇)
            if (data.bbCherryBellHazure > 0) {
                const c = data.bbCherryBellHazure;
                s[1] *= Math.pow(1/81.9, c); s[5] *= Math.pow(1/81.9, c);
                s[2] *= Math.pow(1/41.0, c); s[6] *= Math.pow(1/41.0, c); 
            }

            const total = Object.values(s).reduce((a, b) => a + b) || 1;
            return {
                1: (s[1]/total*100).toFixed(1),
                2: (s[2]/total*100).toFixed(1),
                5: (s[5]/total*100).toFixed(1),
                6: (s[6]/total*100).toFixed(1)
            };
        }

        // ==========================================
        //  2. 画像処理とAPI通信 (ここを追加！)
        // ==========================================
        const fileInput = document.getElementById('file-input');
        const dropZone = document.getElementById('drop-zone');
        const statusText = document.getElementById('p1').parentElement.parentElement.parentElement.previousElementSibling; // "Ready"の場所

        // APIキー保存
        document.getElementById('save-key').onclick = () => {
            const key = document.getElementById('api-key').value;
            if (!key) return alert("APIキーを入力してください");
            localStorage.setItem('v_key', key);
            document.getElementById('key-status').innerText = 'API KEY: READY';
            document.getElementById('key-status').style.color = '#3b82f6';
        };

        // 起動時のキー確認
        const savedKey = localStorage.getItem('v_key');
        if (savedKey) {
            document.getElementById('api-key').value = savedKey;
            document.getElementById('key-status').innerText = 'API KEY: READY';
            document.getElementById('key-status').style.color = '#3b82f6';
        }

        // クリックでファイル選択
        dropZone.onclick = () => fileInput.click();

        // ファイル選択時の処理
        fileInput.onchange = async (e) => {
            const key = localStorage.getItem('v_key');
            if (!key) return alert("先にAPIキーを設定してください！");
            if (e.target.files.length === 0) return;

            // ローディング表示
            const originalText = dropZone.innerHTML;
            dropZone.innerHTML = `<p class="text-xl font-black text-blue-400 animate-pulse">解析中...</p>`;

            let combinedData = {
                totalGames: 0,
                bellACount: 0,
                rbCount: 0,
                rbHazure: 0,
                bbHazure: 0,
                bbCherryBellHazure: 0
            };

            try {
                // 全画像を並列処理
                const promises = Array.from(e.target.files).map(file => processImage(file, key));
                const results = await Promise.all(promises);

                // 結果を合算
                results.forEach(res => {
                    combinedData.totalGames += res.totalGames;
                    combinedData.bellACount += res.bellACount;
                    combinedData.rbCount += res.rbCount;
                    combinedData.rbHazure += res.rbHazure;
                    combinedData.bbHazure += res.bbHazure;
                    combinedData.bbCherryBellHazure += res.bbCherryBellHazure;
                });

                // 計算実行
                const result = analyze(combinedData);
                updateUI(result);
                
                dropZone.innerHTML = `<p class="text-xl font-black text-green-400">解析完了！</p>`;
                setTimeout(() => dropZone.innerHTML = originalText, 2000);

            } catch (err) {
                console.error(err);
                alert("解析エラー: APIキーが正しいか、通信環境を確認してください。\n" + err.message);
                dropZone.innerHTML = originalText;
            }
        };

        // Google Vision API へ送信＆解析
        async function processImage(file, key) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = async () => {
                    const base64Content = reader.result.split(',')[1];
                    const body = {
                        requests: [{
                            image: { content: base64Content },
                            features: [{ type: 'TEXT_DETECTION' }]
                        }]
                    };

                    try {
                        const response = await fetch(`https://vision.googleapis.com/v1/images:annotate?key=${key}`, {
                            method: 'POST',
                            body: JSON.stringify(body),
                            headers: { 'Content-Type': 'application/json' }
                        });
                        const json = await response.json();
                        
                        if (!json.responses || !json.responses[0].fullTextAnnotation) {
                            resolve({ totalGames: 0, bellACount: 0, rbCount: 0, rbHazure: 0, bbHazure: 0, bbCherryBellHazure: 0 });
                            return;
                        }

                        const text = json.responses[0].fullTextAnnotation.text;
                        resolve(parseUniMemoText(text));

                    } catch (err) {
                        reject(err);
                    }
                };
            });
        }

        // テキスト解析（OCR結果から数値を抜く）
        function parseUniMemoText(text) {
            const data = {
                totalGames: 0,
                bellACount: 0,
                rbCount: 0,
                rbHazure: 0,
                bbHazure: 0,
                bbCherryBellHazure: 0
            };

            // 正規表現で数値を抽出 (ユニメモの表記揺れに対応)
            
            // 総プレイ数: "総プレイ数" の後の数値
            const matchG = text.match(/総プレイ数[\s\S]*?(\d+)/);
            if (matchG) data.totalGames = parseInt(matchG[1]);

            // ベルA: "ベルA" の近くにある "XXX回"
            const matchBellA = text.match(/ベルA[\s\S]*?(\d+)回/);
            if (matchBellA) data.bellACount = parseInt(matchBellA[1]);

            // RB (REG): "RB" または "REG" の近くにある "XXX回"
            // 注意: RB確率の分母ではなく回数をとる
            const matchRB = text.match(/RB[\s\S]*?(\d+)回/);
            if (matchRB) data.rbCount = parseInt(matchRB[1]);

            // --- 詳細データ ---
            
            // RB中ハズレ (重要!)
            // "RB中詳細" セクションの中にある "ハズレ" を探すのは難しいので
            // 単純に "ハズレ" と "回" が近くにあるか、行で探す
            // ユニメモ画像では「1枚役」「Xベル」「ハズレ」などが並ぶ
            // 安全策: "1枚役"の下あたりにある数値を拾いたいが、
            // ここでは簡易的に "ハズレ" という単語の直後の回数を拾う
            // ※BB中にもハズレがある場合区別が必要だが、ユニメモの表記順に依存
            
            // 行ごとに分割して解析
            const lines = text.split('\n');
            let section = ""; 

            lines.forEach((line, index) => {
                // セクション判定
                if (line.includes("BB中詳細")) section = "BB";
                if (line.includes("RB中詳細")) section = "RB";

                // 数値抽出 (行末の数字を狙う)
                const numMatch = line.match(/(\d+)回/);
                const count = numMatch ? parseInt(numMatch[1]) : 0;

                if (section === "BB") {
                    if (line.includes("チェリー+ベルはずれ") || line.includes("チェリー+ベル外れ")) {
                        data.bbCherryBellHazure = count;
                    }
                    // 純粋なハズレ (もし項目があれば)
                    else if (line.trim() === "ハズレ" || line.includes("ハズレ回")) { 
                         // 直後の行に回数が来ることがあるため、無ければ次行を見るロジックが必要だが
                         // 一旦同じ行か、近い行で判断
                         data.bbHazure = count; 
                    }
                }

                if (section === "RB") {
                    // RB中のハズレ (5・6確定)
                    // "ハズレ" という単語が含まれ、かつBB中でなければ
                    // ただ、ユニメモのRB中詳細は「1枚役」「Xベル」などが主。
                    // もし「ハズレ」があれば拾う。
                    // 画像7枚目などを参照すると、RB中詳細には通常ハズレ項目はない？
                    // みおちゃんの指示「RB中ハズレは確定」 -> 多分パンク役とかではなく純粋ハズレ
                    // ユニメモに項目がない場合、OCRでは拾えないが、あると仮定して拾う。
                    if (line.includes("ハズレ")) {
                        data.rbHazure = count;
                    }
                }
            });

            return data;
        }

        // UI更新
        function updateUI(res) {
            document.getElementById('p1').innerText = res[1] + "%";
            document.getElementById('bar1').style.width = res[1] + "%";
            
            document.getElementById('p2').innerText = res[2] + "%";
            document.getElementById('bar2').style.width = res[2] + "%";
            
            document.getElementById('p5').innerText = res[5] + "%";
            document.getElementById('bar5').style.width = res[5] + "%";
            
            document.getElementById('p6').innerText = res[6] + "%";
            document.getElementById('bar6').style.width = res[6] + "%";
        }
    </script>