<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>VERSUS REVISE FINAL</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { background-color: #0f172a; color: #f8fafc; font-family: monospace; padding: 20px; }
        .bar-bg { background-color: #1e293b; height: 12px; border-radius: 99px; overflow: hidden; margin-bottom: 12px; }
        .bar-fill { height: 100%; transition: width 0.8s ease-out; }
        #debug-area { 
            font-size: 10px; color: #4ade80; background: #000; padding: 10px; 
            border: 1px solid #22c55e; height: 300px; overflow-y: scroll; 
            white-space: pre-wrap; margin-top: 20px; border-radius: 6px;
        }
    </style>
</head>
<body>
    <div class="max-w-md mx-auto">
        <header class="text-center mb-4">
            <h1 class="text-2xl font-black text-blue-500 italic">VERSUS REVISE</h1>
            <p class="text-[10px] text-red-500 font-bold tracking-[0.3em]">VER 8.0 VISUAL RECONSTRUCTION</p>
        </header>

        <div id="drop-zone" class="border-2 border-dashed border-blue-500/50 rounded-xl p-8 text-center bg-blue-900/10 cursor-pointer active:bg-blue-900/30 transition mb-4">
            <p class="font-bold text-blue-300">画像を解析</p>
            <p class="text-xs text-gray-400 mt-1">※文字の並び順を強制補正します</p>
            <input type="file" id="file-input" class="hidden" accept="image/*">
        </div>

        <div class="bg-slate-900/90 p-4 rounded-xl border border-white/10 shadow-xl mb-4">
            <div class="mb-1 flex justify-between text-xs font-bold"><span class="text-gray-400">設定1</span><span id="p1">0.0%</span></div>
            <div class="bar-bg"><div id="b1" class="bar-fill bg-gray-500" style="width:0%"></div></div>
            
            <div class="mb-1 flex justify-between text-xs font-bold"><span class="text-blue-400">設定2</span><span id="p2">0.0%</span></div>
            <div class="bar-bg"><div id="b2" class="bar-fill bg-blue-500" style="width:0%"></div></div>
            
            <div class="mb-1 flex justify-between text-xs font-bold"><span class="text-orange-400">設定5</span><span id="p5">0.0%</span></div>
            <div class="bar-bg"><div id="b5" class="bar-fill bg-orange-500" style="width:0%"></div></div>
            
            <div class="mb-1 flex justify-between text-xs font-bold"><span class="text-red-500">設定6</span><span id="p6">0.0%</span></div>
            <div class="bar-bg"><div id="b6" class="bar-fill bg-red-600" style="width:0%"></div></div>
        </div>

        <div id="debug-area">待機中...</div>

        <div class="mt-2 flex gap-2">
            <input type="password" id="api-key" placeholder="API Key" class="flex-grow bg-slate-800 border border-slate-600 rounded px-3 text-xs h-10">
            <button id="save-key" class="bg-blue-600 text-xs font-bold px-4 rounded h-10">SET</button>
        </div>
    </div>

    <script>
        // ===============================================
        //  設定差パラメータ (分母)
        // ===============================================
        const TARGETS = {
            bellA:   { 1: 10.9, 2: 10.7, 5: 10.5, 6: 10.2 },
            bellB:   { 1: 20.9, 2: 21.2, 5: 20.3, 6: 20.6 },
            suikaA:  { 1: 74.5, 2: 70.6, 5: 72.5, 6: 68.8 },
            cherryB: { 1: 56.2, 2: 57.7, 5: 53.1, 6: 54.4 },
            bb_total:{ 1: 292.6, 2: 284.9, 5: 275.4, 6: 264.3 },
            rb:      { 1: 374.5, 2: 341.3, 5: 319.7, 6: 292.6 },
            rt_vc:   { 1: 5.0, 2: 4.9, 5: 4.6, 6: 4.5 }, // VS Chance
            rt_vg:   { 1: 10.1, 2: 9.4, 5: 8.7, 6: 8.1 }, // VS Game
            bb_match:{ 1: 11.1, 2: 8.9, 5: 11.1, 6: 8.9 },
            bb_miss: { 1: 256.0, 2: 128.0, 5: 256.0, 6: 128.0 },
            rb_miss: { 1: null, 2: null, 5: 376.6, 6: 376.6 }
        };

        const logArea = document.getElementById('debug-area');
        function log(msg) { logArea.innerText = msg + "\n" + logArea.innerText; }

        // ===============================================
        //  【核】視覚的行復元ロジック (Visual Line Reconstructor)
        // ===============================================
        function parseLines(annotations) {
            // 1. 全単語を取得(0番目の全文は捨てる)
            const words = annotations.slice(1).map(w => ({
                text: w.description,
                x: w.boundingPoly.vertices[0].x,
                y: (w.boundingPoly.vertices[0].y + w.boundingPoly.vertices[3].y) / 2, // 中心のY座標
                h: (w.boundingPoly.vertices[3].y - w.boundingPoly.vertices[0].y) // 高さ
            }));

            // 2. Y座標でソート
            words.sort((a, b) => a.y - b.y);

            // 3. 行ごとにグルーピング
            const lines = [];
            if (words.length > 0) {
                let currentLine = [words[0]];
                for (let i = 1; i < words.length; i++) {
                    const w = words[i];
                    const prev = currentLine[currentLine.length - 1];
                    
                    // 前の文字とのY座標の差が、文字の高さの半分以下なら「同じ行」とみなす
                    if (Math.abs(w.y - prev.y) < (prev.h * 0.6)) {
                        currentLine.push(w);
                    } else {
                        lines.push(currentLine);
                        currentLine = [w];
                    }
                }
                lines.push(currentLine);
            }

            // 4. 各行をX座標順にソートして文字列化
            const textLines = lines.map(line => {
                line.sort((a, b) => a.x - b.x);
                // 単語の間にスペースを入れて連結する
                return line.map(w => w.text).join(' ');
            });

            return textLines;
        }

        // ===============================================
        //  解析 & マッチング
        // ===============================================
        function extractData(lines) {
            log("--- [行認識ログ] ---");
            // デバッグ用に最初の数行を表示
            lines.slice(0, 5).forEach(l => log("Line: " + l)); 
            log("...など (全" + lines.length + "行)");

            const data = {};
            
            // 検索定義
            const mapping = [
                { key: 'bellA',    keywords: ['ベルA', 'ベルＡ'] },
                { key: 'bellB',    keywords: ['ベルB', 'ベルＢ'] },
                { key: 'suikaA',   keywords: ['スイカA', 'スイカＡ'] },
                { key: 'cherryB',  keywords: ['チェリーB', 'チェリーＢ'] },
                { key: 'bb_total', keywords: ['総ボーナス', '合算', '赤７BB', '赤7BB', 'BB確率'] },
                { key: 'rb',       keywords: ['RB', 'REG'] },
                { key: 'rt_vc',    keywords: ['VSチャンス', 'VSチャンス中'] },
                { key: 'rt_vg',    keywords: ['VSGAME', 'VSGAME中'] },
                { key: 'bb_match', keywords: ['チェリー＋ベル揃い', 'チェリー+ベル揃い'] },
                { key: 'bb_miss',  keywords: ['チェリー＋ベルはずれ', 'チェリー+ベルはずれ'] },
                { key: 'rb_miss',  keywords: ['はずれ'] }
            ];

            // スペース対応の正規表現: "1" + (スペース可) + "/"or"|" + (スペース可) + "数字"
            const regex = /1\s*[\/|]\s*([0-9]+\.?[0-9]*)/;

            mapping.forEach(item => {
                // 行を下から探すか上から探すか？ -> RBハズレ以外は上から
                let foundVal = 0;
                
                if (item.key === 'rb_miss') {
                    // RBハズレは一番下にあるはず
                    for (let i = lines.length - 1; i >= 0; i--) {
                        if (lines[i].includes('はずれ')) {
                            const m = lines[i].match(regex);
                            if (m) { foundVal = parseFloat(m[1]); break; }
                        }
                    }
                } else {
                    // 通常項目
                    for (const line of lines) {
                        // キーワードが含まれているか
                        if (item.keywords.some(k => line.includes(k))) {
                            const m = line.match(regex);
                            if (m) { foundVal = parseFloat(m[1]); break; }
                        }
                    }
                }
                data[item.key] = foundVal;
            });

            return data;
        }

        // ===============================================
        //  判定計算
        // ===============================================
        function calculate(data) {
            let scores = { 1: 0, 2: 0, 5: 0, 6: 0 };
            let count = 0;
            let rbMissDetected = false;

            for (const [key, val] of Object.entries(data)) {
                if (!val || val <= 0) continue;
                if (!TARGETS[key]) continue;

                if (key === 'rb_miss') {
                    log(`★神の啓示: RBハズレ(1/${val}) -> 設定1/2否定`);
                    rbMissDetected = true;
                    continue;
                }

                count++;
                [1, 2, 5, 6].forEach(s => {
                    const t = TARGETS[key][s];
                    if (t) {
                        // 誤差率を加算 (小さいほど良い)
                        scores[s] += Math.abs(val - t) / t;
                    }
                });
            }

            if (count === 0 && !rbMissDetected) return null;

            let probs = { 1: 0, 2: 0, 5: 0, 6: 0 };
            let totalInverse = 0;

            [1, 2, 5, 6].forEach(s => {
                if (rbMissDetected && (s === 1 || s === 2)) {
                    probs[s] = 0;
                } else {
                    const p = 1 / (scores[s] + 0.0001);
                    probs[s] = p;
                    totalInverse += p;
                }
            });

            return {
                1: totalInverse ? (probs[1] / totalInverse * 100).toFixed(1) : 0,
                2: totalInverse ? (probs[2] / totalInverse * 100).toFixed(1) : 0,
                5: totalInverse ? (probs[5] / totalInverse * 100).toFixed(1) : 0,
                6: totalInverse ? (probs[6] / totalInverse * 100).toFixed(1) : 0
            };
        }

        // ===============================================
        //  メイン処理
        // ===============================================
        const fileInput = document.getElementById('file-input');
        const dropZone = document.getElementById('drop-zone');
        
        const savedKey = localStorage.getItem('v_key');
        if (savedKey) document.getElementById('api-key').value = savedKey;

        document.getElementById('save-key').onclick = () => {
            localStorage.setItem('v_key', document.getElementById('api-key').value);
            alert("KEY保存");
        };

        dropZone.onclick = () => fileInput.click();

        fileInput.onchange = async (e) => {
            const key = localStorage.getItem('v_key');
            if(!key) return alert("API KEYがありません");
            if(e.target.files.length === 0) return;

            log("\n--- 解析開始 (Ver 8.0) ---");
            const reader = new FileReader();
            reader.readAsDataURL(e.target.files[0]);
            
            reader.onload = async () => {
                try {
                    const res = await fetch(`https://vision.googleapis.com/v1/images:annotate?key=${key}`, {
                        method: 'POST',
                        body: JSON.stringify({ requests: [{ image: { content: reader.result.split(',')[1] }, features: [{ type: 'TEXT_DETECTION' }] }] }),
                        headers: { 'Content-Type': 'application/json' }
                    });
                    const json = await res.json();
                    if (!json.responses || !json.responses[0].textAnnotations) throw new Error("文字認識失敗");

                    // 1. 行を復元
                    const lines = parseLines(json.responses[0].textAnnotations);
                    
                    // 2. データ抽出
                    const data = extractData(lines);
                    
                    log("[抽出データ]");
                    log(`ベルA: 1/${data.bellA} | ベルB: 1/${data.bellB}`);
                    log(`スイカA: 1/${data.suikaA} | チェリーB: 1/${data.cherryB}`);
                    log(`BB合算: 1/${data.bb_total} | RB: 1/${data.rb}`);
                    log(`RTハズレ: VC 1/${data.rt_vc} | VG 1/${data.rt_vg}`);
                    log(`BB詳細: 揃 1/${data.bb_match} | 外 1/${data.bb_miss}`);
                    if(data.rb_miss) log(`RBハズレ: 1/${data.rb_miss}`);

                    // 3. 判定
                    const result = calculate(data);

                    if (result) {
                        document.getElementById('p1').innerText = result[1] + "%"; document.getElementById('b1').style.width = result[1] + "%";
                        document.getElementById('p2').innerText = result[2] + "%"; document.getElementById('b2').style.width = result[2] + "%";
                        document.getElementById('p5').innerText = result[5] + "%"; document.getElementById('b5').style.width = result[5] + "%";
                        document.getElementById('p6').innerText = result[6] + "%"; document.getElementById('b6').style.width = result[6] + "%";
                        log(">> 解析完了");
                    } else {
                        log("エラー: 数値が読み取れませんでした。上記ログを確認してください。");
                    }

                } catch (err) {
                    log("SYSTEM ERROR: " + err.message);
                }
            };
        };
    </script>
</body>
</html>